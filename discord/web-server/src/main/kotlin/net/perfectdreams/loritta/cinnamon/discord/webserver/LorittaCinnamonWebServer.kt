package net.perfectdreams.loritta.cinnamon.discord.webserver

import com.zaxxer.hikari.HikariDataSource
import io.ktor.client.*
import mu.KotlinLogging
import net.perfectdreams.loritta.cinnamon.discord.LorittaCinnamon
import net.perfectdreams.loritta.cinnamon.discord.utils.EventAnalyticsTask
import net.perfectdreams.loritta.cinnamon.discord.webserver.gateway.ProcessDiscordGatewayEvents
import net.perfectdreams.loritta.cinnamon.discord.webserver.gateway.ProxyDiscordGatewayManager
import net.perfectdreams.loritta.cinnamon.discord.webserver.utils.config.RootConfig
import net.perfectdreams.loritta.cinnamon.discord.webserver.webserver.InteractionsServer
import net.perfectdreams.loritta.cinnamon.locale.LanguageManager
import net.perfectdreams.loritta.cinnamon.pudding.Pudding

class LorittaCinnamonWebServer(
    val config: RootConfig,
    private val languageManager: LanguageManager,
    private val services: Pudding,
    private val queueConnection: HikariDataSource,
    private val http: HttpClient,
    private val replicaId: Int
) {
    companion object {
        private val logger = KotlinLogging.logger {}
    }

    private var lastEventCountCheck = 0

    fun start() {
        // To avoid initializing Exposed for our "queueConnection" just to create a table, we will create the table manually with SQL statements (woo, scary!)
        // It is more cumbersome, but hey, it works!
        queueConnection.connection.use {
            val statement = it.createStatement()
            // We will create a UNLOGGED table because it is faster, but if PostgreSQL crashes, all data will be lost
            // Because it is a table that holds gateway events, we don't really care if we can lose all data, as long as it is fast!
            statement.executeUpdate("""
                CREATE UNLOGGED TABLE IF NOT EXISTS ${ProcessDiscordGatewayEvents.DISCORD_GATEWAY_EVENTS_TABLE} (
                    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    type TEXT,
                    received_at TIMESTAMP WITH TIME ZONE,
                    shard INTEGER,
                    payload JSONB
                );
                
                CREATE INDEX IF NOT EXISTS ${ProcessDiscordGatewayEvents.DISCORD_GATEWAY_EVENTS_TABLE}_type ON ${ProcessDiscordGatewayEvents.DISCORD_GATEWAY_EVENTS_TABLE} (type);
                CREATE INDEX IF NOT EXISTS ${ProcessDiscordGatewayEvents.DISCORD_GATEWAY_EVENTS_TABLE}_shard ON ${ProcessDiscordGatewayEvents.DISCORD_GATEWAY_EVENTS_TABLE} (shard);
            """.trimIndent())
            it.commit()
        }

        val proxyDiscordGatewayManager = ProxyDiscordGatewayManager(
            config.totalEventsPerBatch,
            config.discordShards.totalShards,
            config.replicas.instances.firstOrNull { it.replicaId == replicaId } ?: error("Missing replica configuration for replica ID $replicaId"),
            services,
            queueConnection
        )

        val cinnamon = LorittaCinnamon(
            proxyDiscordGatewayManager,
            config.cinnamon,
            languageManager,
            services,
            http
        )

        cinnamon.start()

        // Start processing gateway events
        Thread(
            null,
            proxyDiscordGatewayManager.discordGatewayEventsProcessor,
            "Gateway Events Poller"
        ).start()

        cinnamon.addAnalyticHandler {
            val totalEventsProcessed = proxyDiscordGatewayManager.discordGatewayEventsProcessor.totalEventsProcessed
            EventAnalyticsTask.logger.info { "Total Discord Events processed: $totalEventsProcessed; (+${totalEventsProcessed - lastEventCountCheck})" }
            lastEventCountCheck = totalEventsProcessed
        }

        val interactionsServer = InteractionsServer(
            cinnamon.interaKTions,
            config.httpInteractions.publicKey
        )

        interactionsServer.start()
    }
}